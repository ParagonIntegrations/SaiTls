use smoltcp_tls::tls::TlsSocket;
use smoltcp::socket::TcpSocketBuffer;
use smoltcp::socket::SocketSet;
use smoltcp::wire::Ipv4Address;

use rand_core::RngCore;
use rand_core::CryptoRng;
use rand_core::impls;
use rand_core::Error;

use p256::{EncodedPoint, AffinePoint, ecdh::EphemeralSecret, ecdh::SharedSecret};
use aes_gcm::{Aes128Gcm, Aes256Gcm};
use chacha20poly1305::{ChaCha20Poly1305, Key};
use ccm::{Ccm, consts::*};
use aes_gcm::aes::Aes128;
use aes_gcm::{AeadInPlace, NewAead};
use generic_array::GenericArray;
use sha2::{ Digest, Sha256, Sha384, Sha512 };
use heapless::Vec;
use hkdf::Hkdf;

use smoltcp_tls::key::*;
use smoltcp_tls::buffer::TlsBuffer;


struct CountingRng(u64);

impl RngCore for CountingRng {
	fn next_u32(&mut self) -> u32 {
		self.next_u64() as u32
	}

	fn next_u64(&mut self) -> u64 {
		self.0 += 1;
		self.0
	}

	fn fill_bytes(&mut self, dest: &mut [u8]) {
		impls::fill_bytes_via_next(self, dest)
	}

	fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
		Ok(self.fill_bytes(dest))
	}
}

impl CryptoRng for CountingRng {}

static mut RNG: CountingRng = CountingRng(0);

fn main() {
	let mut socket_set_entries: [_; 8] = Default::default();
	let mut sockets = SocketSet::new(&mut socket_set_entries[..]);

	let mut tx_storage = [0; 4096];
	let mut rx_storage = [0; 4096];

	let mut tls_socket = unsafe {
		let tx_buffer = TcpSocketBuffer::new(&mut tx_storage[..]);
		let rx_buffer = TcpSocketBuffer::new(&mut rx_storage[..]);
		TlsSocket::new(
			&mut sockets,
			rx_buffer,
			tx_buffer,
			&mut RNG,
		)
	};

	tls_socket.tcp_connect(
		&mut sockets,
		(Ipv4Address::new(192, 168, 1, 125), 1883),
		49600
	).unwrap();

//	tls_socket.tls_connect(&mut sockets).unwrap();

	let hello_hash = {
		Sha384::new()
			.chain(&CLIENT_HELLO)
			.chain(&SERVER_HELLO)
			.finalize()
	};
	println!("Hash: {:?}", hello_hash);

	let psk: [u8; 48] = [0; 48];
	let early_secret = Hkdf::<Sha384>::new(None, &psk);
	let derived_secret = derive_secret(
		&early_secret,
		"derived",
		Sha384::new().chain("")
	);
	let (handshake_secret, handshake_secret_hkdf) = Hkdf::<Sha384>::extract(
		Some(&derived_secret),
		&SHARED_SECRET
	);
	let client_handshake_traffic_secret = {
		let hkdf_label = HkdfLabel {
			length: 48,
			label_length: 18,
			label: b"tls13 c hs traffic",
			context_length: 48,
			context: &hello_hash,
		};
		let mut array = [0; 100];
		let mut buffer = TlsBuffer::new(&mut array);
		buffer.enqueue_hkdf_label(hkdf_label);
		let info: &[u8] = buffer.into();

		// Define output key material (OKM), dynamically sized by hash
		let mut okm: GenericArray<u8, U48> = GenericArray::default();
		handshake_secret_hkdf.expand(info, &mut okm).unwrap();
		okm
	};
	
	let server_handshake_traffic_secret = {
		let hkdf_label = HkdfLabel {
			length: 48,
			label_length: 18,
			label: b"tls13 s hs traffic",
			context_length: 48,
			context: &hello_hash,
		};
		let mut array = [0; 100];
		let mut buffer = TlsBuffer::new(&mut array);
		buffer.enqueue_hkdf_label(hkdf_label);
		let info: &[u8] = buffer.into();

		// Define output key material (OKM), dynamically sized by hash
		let mut okm: GenericArray<u8, U48> = GenericArray::default();
		handshake_secret_hkdf.expand(info, &mut okm).unwrap();
		okm
	};

	let server_handshake_write_key = {
		let hkdf_label = HkdfLabel {
			length: 32,
			label_length: 9,
			label: b"tls13 key",
			context_length: 0,
			context: b"",
		};
		let mut array = [0; 100];
		let mut buffer = TlsBuffer::new(&mut array);
		buffer.enqueue_hkdf_label(hkdf_label);
		let info: &[u8] = buffer.into();

		// Define output key material (OKM), dynamically sized by cipher key
		let mut okm: GenericArray<u8, U32> = GenericArray::default();
		Hkdf::<Sha384>::from_prk(&server_handshake_traffic_secret)
			.unwrap()
			.expand(info, &mut okm);
		okm
	};
	let server_handshake_write_iv = {
		let hkdf_label = HkdfLabel {
			length: 12,
			label_length: 8,
			label: b"tls13 iv",
			context_length: 0,
			context: b"",
		};
		let mut array = [0; 100];
		let mut buffer = TlsBuffer::new(&mut array);
		buffer.enqueue_hkdf_label(hkdf_label);
		let info: &[u8] = buffer.into();

		// Define output key material (OKM), dynamically sized by hash
		let mut okm: GenericArray<u8, U12> = GenericArray::default();
		Hkdf::<Sha384>::from_prk(&server_handshake_traffic_secret)
			.unwrap()
			.expand(info, &mut okm);
		okm
	};
	let cipher: Aes256Gcm = Aes256Gcm::new(&server_handshake_write_key);
	let decrypted_data = {
		let mut vec: Vec<u8, U2048> = Vec::from_slice(&CIPHERTEXT).unwrap();
		cipher.decrypt_in_place(
			&server_handshake_write_iv,
			&[
				0x17, 0x03, 0x03, 0x00, 0x27
			],
			&mut vec
		).unwrap();
		vec
	};

	println!("{:x?}", client_handshake_traffic_secret);
	println!("{:x?}", server_handshake_traffic_secret);
	println!("Server handshake key: {:?}", server_handshake_write_key);
	println!("Server handshake iv: {:?}", server_handshake_write_iv);
	println!("{:x?}", decrypted_data);
	println!("Decrypted data length: {:?}", decrypted_data.len());
}

const SHARED_SECRET: [u8; 32] = [
	43, 165, 163, 26, 69, 90, 77, 219, 49, 63, 128, 28, 75, 77, 23, 115, 28, 228, 145, 134, 124, 198, 18, 28, 27, 165, 10, 201, 94, 156, 148, 150
];

const CLIENT_HELLO: [u8; 0xCB] = [
	0x01, 0x00, 0x00, 0xc7, 0x03, 0x03, 0x95, 0x2a, 0xfc, 0xc8, 0xee, 0x76, 0xab, 0xaf, 0x6e, 0x99, 
	0xd0, 0x63, 0x03, 0x0b, 0x7d, 0x5e, 0x44, 0xa2, 0x2d, 0x00, 0x99, 0xb4, 0x10, 0x0b, 0x22, 0x55, 
	0xf6, 0xe9, 0x7e, 0xbf, 0xdc, 0xd5, 0x20, 0x81, 0x52, 0xe7, 0x4f, 0x58, 0x54, 0x5a, 0x9f, 0x89, 
	0xc1, 0x2b, 0xd5, 0x40, 0x61, 0x53, 0xeb, 0x50, 0x8e, 0x77, 0x3a, 0xa9, 0x44, 0x07, 0x0c, 0x2c, 
	0xab, 0xeb, 0xf5, 0x6b, 0x3d, 0x91, 0x6e, 0x00, 0x08, 0x13, 0x01, 0x13, 0x02, 0x13, 0x03, 0x13, 
	0x04, 0x01, 0x00, 0x00, 0x76, 0x00, 0x2b, 0x00, 0x03, 0x02, 0x03, 0x04, 0x00, 0x0d, 0x00, 0x18, 
	0x00, 0x16, 0x04, 0x03, 0x08, 0x07, 0x08, 0x09, 0x04, 0x01, 0x08, 0x04, 0x08, 0x0a, 0x05, 0x01, 
	0x08, 0x05, 0x08, 0x0b, 0x06, 0x01, 0x08, 0x06, 0x00, 0x0a, 0x00, 0x04, 0x00, 0x02, 0x00, 0x17, 
	0x00, 0x33, 0x00, 0x47, 0x00, 0x45, 0x00, 0x17, 0x00, 0x41, 0x04, 0x0e, 0x9f, 0xff, 0x47, 0x1c, 
	0x7c, 0xa3, 0xf8, 0x24, 0xfe, 0x25, 0x57, 0x37, 0xbb, 0x0b, 0xe2, 0x11, 0xb2, 0xec, 0x5f, 0xa9, 
	0x33, 0x2f, 0x66, 0xe8, 0x18, 0xb4, 0x1d, 0x44, 0x61, 0xca, 0x91, 0x89, 0x5f, 0xa2, 0x0f, 0x01, 
	0x88, 0x97, 0xed, 0xe8, 0xc8, 0x39, 0x71, 0x89, 0x93, 0x7d, 0x35, 0xc2, 0xce, 0xcb, 0x6b, 0xbb, 
	0xe0, 0x3f, 0xe5, 0xde, 0x6e, 0x3b, 0x17, 0x68, 0x91, 0xbb, 0xe9
];

const SERVER_HELLO: [u8; 0x9B] = [
	0x02, 0x00, 0x00, 0x97, 0x03, 0x03, 0x5a, 0x7a, 0x25, 0x58, 0x0a, 0x34, 0x9c, 0x66, 0x08, 0x1f, 
	0xbf, 0x98, 0x03, 0xd3, 0x55, 0x37, 0x14, 0xe9, 0xdb, 0xfb, 0x12, 0xf3, 0x8c, 0x69, 0x1e, 0xc1, 
	0xd4, 0xfc, 0x67, 0x4b, 0x06, 0x47, 0x20, 0x81, 0x52, 0xe7, 0x4f, 0x58, 0x54, 0x5a, 0x9f, 0x89, 
	0xc1, 0x2b, 0xd5, 0x40, 0x61, 0x53, 0xeb, 0x50, 0x8e, 0x77, 0x3a, 0xa9, 0x44, 0x07, 0x0c, 0x2c, 
	0xab, 0xeb, 0xf5, 0x6b, 0x3d, 0x91, 0x6e, 0x13, 0x02, 0x00, 0x00, 0x4f, 0x00, 0x2b, 0x00, 0x02, 
	0x03, 0x04, 0x00, 0x33, 0x00, 0x45, 0x00, 0x17, 0x00, 0x41, 0x04, 0xb9, 0x93, 0x81, 0xfd, 0xa5, 
	0xdc, 0x6d, 0xe2, 0x64, 0x44, 0xbe, 0xa6, 0xd4, 0x7f, 0x8c, 0x0e, 0xb3, 0x6f, 0x4a, 0xcf, 0xa1, 
	0x73, 0x1b, 0x3c, 0x93, 0x41, 0xef, 0x97, 0x2c, 0x3a, 0x2a, 0xd4, 0xb1, 0xe8, 0xc3, 0x06, 0x3a, 
	0xf8, 0x2e, 0x8a, 0xf3, 0x35, 0x0a, 0x47, 0x98, 0x47, 0x67, 0x28, 0xab, 0x9d, 0xd2, 0xb4, 0x98, 
	0x33, 0xc6, 0xa5, 0x3d, 0x99, 0x7e, 0x28, 0x89, 0x2d, 0x9d, 0xd9
];

const CIPHERTEXT: [u8; 39] = [
	0xf6, 0xa9, 0x89, 0x64, 0x69, 0xf7, 0x87, 0x96, 0x61, 0xf6, 0xc9, 0xf8, 0x02, 0xfb, 0xfa, 0xa0, 
	0xae, 0xca, 0x4f, 0x59, 0x9b, 0xb4, 0x26, 0x2b, 0x06, 0x54, 0x4b, 0xce, 0xbc, 0xa4, 0x27, 0x55, 
	0xc0, 0xe4, 0x69, 0x33, 0x25, 0x46, 0x7f
];